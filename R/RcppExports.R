# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

CAR_ALASSO_hir_Cpp <- function(data, design, link, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, lambda_diag, ns, m, emax, progress) {
    .Call(`_CARlasso_CAR_ALASSO_hir_Cpp`, data, design, link, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, lambda_diag, ns, m, emax, progress)
}

CAR_ALASSO_Cpp <- function(data, design, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, lambda_diag, progress) {
    .Call(`_CARlasso_CAR_ALASSO_Cpp`, data, design, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, lambda_diag, progress)
}

CAR_LASSO_hir_Cpp <- function(data, design, link, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, ns, m, emax, progress) {
    .Call(`_CARlasso_CAR_LASSO_hir_Cpp`, data, design, link, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, ns, m, emax, progress)
}

CAR_LASSO_Cpp <- function(data, design, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, progress) {
    .Call(`_CARlasso_CAR_LASSO_Cpp`, data, design, n_iter, n_burn_in, thin_by, r_beta, delta_beta, r_Omega, delta_Omega, progress)
}

update_car_tau2_adp_helper <- function(beta, lambda2, Omega, k, p, n) {
    .Call(`_CARlasso_update_car_tau2_adp_helper`, beta, lambda2, Omega, k, p, n)
}

update_car_lambda_Omega_adp_helper <- function(lambda_curr, Omega, r, delta) {
    invisible(.Call(`_CARlasso_update_car_lambda_Omega_adp_helper`, lambda_curr, Omega, r, delta))
}

update_car_beta_helper <- function(data, design, mu, tau2, Omega, k, p, n) {
    .Call(`_CARlasso_update_car_beta_helper`, data, design, mu, tau2, Omega, k, p, n)
}

update_car_mu_helper <- function(data, design, beta, Omega, k, p, n) {
    .Call(`_CARlasso_update_car_mu_helper`, data, design, beta, Omega, k, p, n)
}

update_car_Omega_helper <- function(Omega, data, design, mu, beta, lambda_curr, k, p, n) {
    invisible(.Call(`_CARlasso_update_car_Omega_helper`, Omega, data, design, mu, beta, lambda_curr, k, p, n))
}

update_car_tau2_helper <- function(beta, lambda2, Omega, k, p, n) {
    .Call(`_CARlasso_update_car_tau2_helper`, beta, lambda2, Omega, k, p, n)
}

sample_Omega_prior_cpp <- function(k, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, progress) {
    .Call(`_CARlasso_sample_Omega_prior_cpp`, k, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, progress)
}

rgig <- function(lambda, chi, psi) {
    .Call(`_CARlasso_rgig`, lambda, chi, psi)
}

update_Z_helper_CAR <- function(Z_curr, data, design, mu_curr, beta_curr, Omega_curr, k, p, n) {
    invisible(.Call(`_CARlasso_update_Z_helper_CAR`, Z_curr, data, design, mu_curr, beta_curr, Omega_curr, k, p, n))
}

rtn1 <- function(mean, sd, low, high) {
    .Call(`_CARlasso_rtn1`, mean, sd, low, high)
}

update_Z_helper_multinomial <- function(Z_curr, mu_Z, Sigma_Z, y, k, p, n, ns, m, emax) {
    invisible(.Call(`_CARlasso_update_Z_helper_multinomial`, Z_curr, mu_Z, Sigma_Z, y, k, p, n, ns, m, emax))
}

update_Z_helper_Pois <- function(Z_curr, mu_Z, Sigma_Z, y, k, p, n, ns, m, emax) {
    invisible(.Call(`_CARlasso_update_Z_helper_Pois`, Z_curr, mu_Z, Sigma_Z, y, k, p, n, ns, m, emax))
}

update_Z_helper_Pois_reg <- function(Z_curr, data, design, mu_curr, beta_curr, Omega_curr, k, p, n, ns, m, emax) {
    invisible(.Call(`_CARlasso_update_Z_helper_Pois_reg`, Z_curr, data, design, mu_curr, beta_curr, Omega_curr, k, p, n, ns, m, emax))
}

Intercept_Graphical_ALASSO_Cpp <- function(data, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, lambda_diag, progress) {
    .Call(`_CARlasso_Intercept_Graphical_ALASSO_Cpp`, data, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, lambda_diag, progress)
}

Intercept_Graphical_ALASSO_hir_Cpp <- function(data, link, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, lambda_diag, ns, m, emax, progress) {
    .Call(`_CARlasso_Intercept_Graphical_ALASSO_hir_Cpp`, data, link, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, lambda_diag, ns, m, emax, progress)
}

Intercept_Graphical_LASSO_Cpp <- function(data, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, progress) {
    .Call(`_CARlasso_Intercept_Graphical_LASSO_Cpp`, data, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, progress)
}

Intercept_Graphical_LASSO_hir_Cpp <- function(data, link, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, ns, m, emax, progress) {
    .Call(`_CARlasso_Intercept_Graphical_LASSO_hir_Cpp`, data, link, n_iter, n_burn_in, thin_by, lambda_a, lambda_b, ns, m, emax, progress)
}

rinvGau <- function(mu, lambda) {
    .Call(`_CARlasso_rinvGau`, mu, lambda)
}

stein_loss_cpp <- function(Omega, Omega_hat) {
    .Call(`_CARlasso_stein_loss_cpp`, Omega, Omega_hat)
}

CAR_multireg_cpp <- function(data, design, n_sample, Bbar, A, nu, V) {
    .Call(`_CARlasso_CAR_multireg_cpp`, data, design, n_sample, Bbar, A, nu, V)
}

Multinomial_CAR_multireg_cpp <- function(data, design, n_burn_in, n_iter, thin_by, Bbar, A, nu, V, ns, m, emax) {
    .Call(`_CARlasso_Multinomial_CAR_multireg_cpp`, data, design, n_burn_in, n_iter, thin_by, Bbar, A, nu, V, ns, m, emax)
}

Pois_CAR_multireg_cpp <- function(data, design, n_burn_in, n_iter, thin_by, Bbar, A, nu, V, ns, m, emax) {
    .Call(`_CARlasso_Pois_CAR_multireg_cpp`, data, design, n_burn_in, n_iter, thin_by, Bbar, A, nu, V, ns, m, emax)
}

Probit_CAR_multireg_cpp <- function(data, design, n_burn_in, n_iter, thin_by, Bbar, A, nu, V) {
    .Call(`_CARlasso_Probit_CAR_multireg_cpp`, data, design, n_burn_in, n_iter, thin_by, Bbar, A, nu, V)
}

#' @title Block Gibbs sampler for adaptive CAR-LASSO
#'
#' @description \strong{This function is for advanced users to build their own sampler use adaptive CARlasso as core.} It will execute one round of Gibbs sampler of adaptive CAR-LASSO model. Be aware that the function is a `void` function implemented in C++, and all updated parameters e.g. Omega will be manipulate directly in memory to save space. Users should manage to do their own work to save the state. Also be aware that R uses shallow copy by default, which means one cannot save the state by simply give it to another object e.g. first `Omega_old <- Omega_curr` then update `Omega_curr`, `Omega_old` will also change. \strong{This function will NOT check dimensions of input.} Below we assume n samples, k responses and p predictors.
#' @param Z_curr the current (latent) normal Z_curr, should be n*k. Will not be changed
#' @param design the design matrix, should be n*p. Will not be changed
#' @param lambda2_beta the current shrinkage parameter of regression coefficients, should be a vector with p*k entries. Will be updated
#' @param tau2_curr the current latent scale parameter in the normal mixture representation of Laplace, for regression coefficients, should be a vector with p*k entries. Will be updated.
#' @param beta_curr the current regression coefficients, should be a matrix sized p*k (p row and k columns). Will be updated.
#' @param lambda_Omega the current shrinkage parameter for Omega, should be a vector with k*(k-1)/2 entries. Will be updated.
#' @param Omega_curr the current Omega matrix, should be a matrix of size k*k. Will be updated.
#' @param mu_curr the current mu, intercept, should be a vector of size k. Will be updated.
#' @param r_beta hyperprior's parameter of shrinkage for regression coefficients, should be a scalar of type 'double' and positive. Will not be updated.
#' @param delta_beta hyperprior's parameter of shrinkage for regression coefficients, should be a scalar of type 'double' and positive. Will not be updated.
#' @param r_Omega hyperprior's parameter of shrinkage for precision Omega, should be a scalar of type 'double' and positive. Will not be updated.
#' @param delta_Omega hyperprior's parameter of shrinkage for rprecision Omega, should be a scalar of type 'double' and positive. Will not be updated.
#' @param lambda_diag shrinkage parameter of the diagonal of Omega, should be a vector of size k, should be non-negative. Will not be updated
#' @param k integer, number of responses
#' @param p integer, number of predictors
#' @param n integer, number of Z_curr points
#' @return Again this is a `void` function and will not return anything. All update happened in memory directly. 
rCARAlasso_ <- function(Z_curr, design, lambda2_beta, tau2_curr, beta_curr, lambda_Omega, Omega_curr, mu_curr, r_beta, delta_beta, r_Omega, delta_Omega, lambda_diag, k, p, n) {
    invisible(.Call(`_CARlasso_rCARAlasso_`, Z_curr, design, lambda2_beta, tau2_curr, beta_curr, lambda_Omega, Omega_curr, mu_curr, r_beta, delta_beta, r_Omega, delta_Omega, lambda_diag, k, p, n))
}

#' @title Block Gibbs sampler for CAR-LASSO
#'
#' @description \strong{This function is for advanced users to build their own sampler use CARlasso as core.} It will execute one round of Gibbs sampler of CAR-LASSO model. Be aware that the function is a `void` function implemented in C++, and all updated parameters e.g. Omega will be manipulate directly in memory to save space. Users should manage to do their own work to save the state. Also be aware that R uses shallow copy by default, which means one cannot save the state by simply give it to another object e.g. first `Omega_old <- Omega_curr` then update `Omega_curr`, `Omega_old` will also change. \strong{This function will NOT check dimensions of input.} Below we assume n samples, k responses and p predictors.
#' 
#' @param Z_curr the current (latent) normal data, should be n*k. Will not be changed
#' @param design the design matrix, should be n*p. Will not be changed
#' @param lambda2_beta the current shrinkage parameter of regression coefficients, should be a scalar of type `double`. Will be updated
#' @param tau2_curr the current latent scale parameter in the normal mixture representation of Laplace, for regression coefficients, should be a vector with p*k entries. Will be updated.
#' @param beta_curr the current regression coefficients, should be a matrix sized p*k (p row and k columns). Will be updated.
#' @param lambda_Omega the current shrinkage parameter for Omega, should be a scalar of tyoe `double`. Will be updated.
#' @param Omega_curr the current Omega matrix, should be a matrix of size k*k. Will be updated.
#' @param mu_curr the current mu, intercept, should be a vector of size k. Will be updated.
#' @param r_beta hyperprior's parameter of shrinkage for regression coefficients, should be a scalar of type 'double' and positive. Will not be updated.
#' @param delta_beta hyperprior's parameter of shrinkage for regression coefficients, should be a scalar of type 'double' and positive. Will not be updated.
#' @param r_Omega hyperprior's parameter of shrinkage for precision Omega, should be a scalar of type 'double' and positive. Will not be updated.
#' @param delta_Omega hyperprior's parameter of shrinkage for rprecision Omega, should be a scalar of type 'double' and positive. Will not be updated.
#' @param k integer, number of responses
#' @param p integer, number of predictors
#' @param n integer, number of data points
#' @return Again this is a `void` function and will not return anything. All update happened in memory directly. 
#' @export
rCARlasso_ <- function(Z_curr, design, lambda2_beta, tau2_curr, beta_curr, lambda_Omega, Omega_curr, mu_curr, r_beta, delta_beta, r_Omega, delta_Omega, k, p, n) {
    invisible(.Call(`_CARlasso_rCARlasso_`, Z_curr, design, lambda2_beta, tau2_curr, beta_curr, lambda_Omega, Omega_curr, mu_curr, r_beta, delta_beta, r_Omega, delta_Omega, k, p, n))
}

